--- a/src/subnet.c
+++ b/src/subnet.c
@@ -53,7 +53,7 @@ static mac_t cache_mac_address[CACHE_SIZ
 static vlan_t cache_mac_vlan_id[CACHE_SIZE];
 static subnet_t *cache_mac_subnet[CACHE_SIZE];
 static bool cache_mac_valid[CACHE_SIZE];
-static int cache_mac_slot;
+static time_t cache_mac_lru[CACHE_SIZE];
 
 void subnet_cache_flush(void) {
 	int i;
@@ -448,14 +448,26 @@ subnet_t *lookup_subnet_mac(const node_t
 	subnet_t *p, *r = NULL;
 	avl_node_t *n;
 	int i;
+	time_t min_lru = now + 1;
+	int cache_mac_slot = 0;
 
 	// Check if this address is cached
 
 	for(i = 0; i < CACHE_SIZE; i++) {
+		if(!cache_mac_valid[i] && min_lru != 0) {
+			min_lru = 0;
+			cache_mac_slot = i;
+		}
+
 		if(!cache_mac_valid[i]) {
 			continue;
 		}
 
+		if (min_lru > cache_mac_lru[i]) {
+			min_lru = cache_mac_lru[i];
+			cache_mac_slot = i;
+		}
+
 		if(owner && cache_mac_subnet[i] && cache_mac_subnet[i]->owner != owner) {
 			continue;
 		}
@@ -463,9 +475,11 @@ subnet_t *lookup_subnet_mac(const node_t
 		if(vlan_id != cache_mac_vlan_id[i])
 			continue;
 
-		if(!memcmp(address, &cache_mac_address[i], sizeof(*address))) {
-			return cache_mac_subnet[i];
-		}
+		if(memcmp(address, &cache_mac_address[i], sizeof(*address)))
+			continue;
+
+		cache_mac_lru[i] = now;
+		return cache_mac_subnet[i];
 	}
 
 	// Search all subnets for a matching one
@@ -488,11 +502,11 @@ subnet_t *lookup_subnet_mac(const node_t
 
 	// Cache the result
 
-	cache_mac_slot = (cache_mac_slot + 1) % CACHE_SIZE;
 	memcpy(&cache_mac_address[cache_mac_slot], address, sizeof(*address));
 	cache_mac_subnet[cache_mac_slot] = r;
 	cache_mac_vlan_id[cache_mac_slot] = vlan_id;
 	cache_mac_valid[cache_mac_slot] = true;
+	cache_mac_lru[cache_mac_slot] = now;
 
 	return r;
 }
