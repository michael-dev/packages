commit e43c5ce8b364537340383aa559f73b3ff8117143
Author: Michael Braun <michael-dev@fami-braun.de>
Date:   Mon Jan 5 11:23:09 2015 +0100

    add support for per-vlan forwarding

diff --git a/src/net.h b/src/net.h
index 0982020..576d009 100644
--- a/src/net.h
+++ b/src/net.h
@@ -40,6 +40,8 @@ typedef struct mac_t {
 	uint8_t x[6];
 } mac_t;
 
+typedef uint16_t vlan_t;
+
 typedef struct ipv4_t {
 	uint8_t x[4];
 } ipv4_t;
diff --git a/src/route.c b/src/route.c
index c11267b..d958dd0 100644
--- a/src/route.c
+++ b/src/route.c
@@ -187,24 +187,25 @@ static void swap_mac_addresses(vpn_packet_t *packet) {
 	memcpy(&packet->data[6], &tmp, sizeof tmp);
 }
 	
-static void learn_mac(mac_t *address) {
+static void learn_mac(mac_t *address, vlan_t vlan_id) {
 	subnet_t *subnet;
 	avl_node_t *node;
 	connection_t *c;
 
-	subnet = lookup_subnet_mac(myself, address);
+	subnet = lookup_subnet_mac(myself, address, vlan_id);
 
 	/* If we don't know this MAC address yet, store it */
 
 	if(!subnet) {
-		ifdebug(TRAFFIC) logger(LOG_INFO, "Learned new MAC address %x:%x:%x:%x:%x:%x",
+		ifdebug(TRAFFIC) logger(LOG_INFO, "Learned new MAC address %x:%x:%x:%x:%x:%x in VLAN %d",
 				   address->x[0], address->x[1], address->x[2], address->x[3],
-				   address->x[4], address->x[5]);
+				   address->x[4], address->x[5], vlan_id);
 
 		subnet = new_subnet();
 		subnet->type = SUBNET_MAC;
 		subnet->expires = now + macexpire;
 		subnet->net.mac.address = *address;
+		subnet->net.mac.vlan = vlan_id;
 		subnet->weight = 10;
 		subnet_add(myself, subnet);
 		subnet_update(myself, subnet, true);
@@ -809,19 +810,31 @@ static void route_arp(node_t *source, vpn_packet_t *packet) {
 static void route_mac(node_t *source, vpn_packet_t *packet) {
 	subnet_t *subnet;
 	mac_t dest;
+	vlan_t vlan_id;
+
+	/* detect vlan */
+	length_t ethlen = ether_size;
+	uint16_t type = packet->data[ethlen-2] << 8 | packet->data[ethlen-1];
+	if(type == ETH_P_8021Q) {
+		vlan_id = (packet->data[ethlen] & 0x0f) * 256 + packet->data[ethlen+1]; // network byte order beachten!
+		ethlen += 4;
+		type = packet->data[ethlen-2] << 8 | packet->data[ethlen-1];
+	} else {
+		vlan_id = 0;
+	}
 
 	/* Learn source address */
 
 	if(source == myself) {
 		mac_t src;
 		memcpy(&src, &packet->data[6], sizeof src);
-		learn_mac(&src);
+		learn_mac(&src, vlan_id);
 	}
 
 	/* Lookup destination address */
 
 	memcpy(&dest, &packet->data[0], sizeof dest);
-	subnet = lookup_subnet_mac(NULL, &dest);
+	subnet = lookup_subnet_mac(NULL, &dest, vlan_id);
 
 	if(!subnet) {
 		broadcast_packet(source, packet);
@@ -836,10 +849,9 @@ static void route_mac(node_t *source, vpn_packet_t *packet) {
 	if(forwarding_mode == FMODE_OFF && source != myself && subnet->owner != myself)
 		return;
 
-	uint16_t type = packet->data[12] << 8 | packet->data[13];
 
-	if(priorityinheritance && type == ETH_P_IP && packet->len >= ether_size + ip_size)
-		packet->priority = packet->data[15];
+	if(priorityinheritance && type == ETH_P_IP && packet->len >= ethlen + ip_size)
+		packet->priority = packet->data[ethlen+1];
 
 	// Handle packets larger than PMTU
 
@@ -850,12 +862,6 @@ static void route_mac(node_t *source, vpn_packet_t *packet) {
 	
 	if(via && packet->len > via->mtu && via != myself) {
 		ifdebug(TRAFFIC) logger(LOG_INFO, "Packet for %s (%s) length %d larger than MTU %d", subnet->owner->name, subnet->owner->hostname, packet->len, via->mtu);
-		length_t ethlen = 14;
-
-		if(type == ETH_P_8021Q) {
-			type = packet->data[16] << 8 | packet->data[17];
-			ethlen += 4;
-		}
 
 		if(type == ETH_P_IP && packet->len > 576 + ethlen) {
 			if(packet->data[6 + ethlen] & 0x40) {
diff --git a/src/subnet.c b/src/subnet.c
index 6e8ad07..1156f69 100644
--- a/src/subnet.c
+++ b/src/subnet.c
@@ -48,6 +48,7 @@ static bool cache_ipv6_valid[2];
 static int cache_ipv6_slot;
 
 static mac_t cache_mac_address[2];
+static vlan_t cache_mac_vlan_id[2];
 static subnet_t *cache_mac_subnet[2];
 static bool cache_mac_valid[2];
 static int cache_mac_slot;
@@ -63,11 +64,16 @@ void subnet_cache_flush(void) {
 static int subnet_compare_mac(const subnet_t *a, const subnet_t *b) {
 	int result;
 
+	result = memcmp(&a->net.mac.vlan, &b->net.mac.vlan, sizeof(vlan_t));
+
+	if(result)
+		return result;
+
 	result = memcmp(&a->net.mac.address, &b->net.mac.address, sizeof(mac_t));
 
 	if(result)
 		return result;
-	
+
 	result = a->weight - b->weight;
 
 	if(result || !a->owner || !b->owner)
@@ -195,6 +201,7 @@ void subnet_del(node_t *n, subnet_t *subnet) {
 bool str2net(subnet_t *subnet, const char *subnetstr) {
 	int i, l;
 	uint16_t x[8];
+	unsigned int vlan_id;
 	int weight = 10;
 
 	if(sscanf(subnetstr, "%hu.%hu.%hu.%hu/%d#%d",
@@ -257,14 +264,16 @@ bool str2net(subnet_t *subnet, const char *subnetstr) {
 		return true;
 	}
 
-	if(sscanf(subnetstr, "%hx:%hx:%hx:%hx:%hx:%hx#%d",
-			  &x[0], &x[1], &x[2], &x[3], &x[4], &x[5], &weight) >= 6) {
+	if(sscanf(subnetstr, "%hx:%hx:%hx:%hx:%hx:%hx@%u#%d",
+			  &x[0], &x[1], &x[2], &x[3], &x[4], &x[5], &vlan_id, &weight) >= 6) {
 		subnet->type = SUBNET_MAC;
 		subnet->weight = weight;
 
 		for(i = 0; i < 6; i++)
 			subnet->net.mac.address.x[i] = x[i];
 
+		subnet->net.mac.vlan = vlan_id;
+
 		return true;
 	}
 
@@ -351,13 +360,14 @@ bool net2str(char *netstr, int len, const subnet_t *subnet) {
 
 	switch (subnet->type) {
 		case SUBNET_MAC:
-			snprintf(netstr, len, "%x:%x:%x:%x:%x:%x#%d",
+			snprintf(netstr, len, "%x:%x:%x:%x:%x:%x@%u#%d",
 					 subnet->net.mac.address.x[0],
 					 subnet->net.mac.address.x[1],
 					 subnet->net.mac.address.x[2],
 					 subnet->net.mac.address.x[3],
 					 subnet->net.mac.address.x[4],
 					 subnet->net.mac.address.x[5],
+					 subnet->net.mac.vlan,
 					 subnet->weight);
 			break;
 
@@ -401,7 +411,7 @@ subnet_t *lookup_subnet(const node_t *owner, const subnet_t *subnet) {
 	return avl_search(owner->subnet_tree, subnet);
 }
 
-subnet_t *lookup_subnet_mac(const node_t *owner, const mac_t *address) {
+subnet_t *lookup_subnet_mac(const node_t *owner, const mac_t *address, const vlan_t vlan_id) {
 	subnet_t *p, *r = NULL;
 	avl_node_t *n;
 	int i;
@@ -413,6 +423,8 @@ subnet_t *lookup_subnet_mac(const node_t *owner, const mac_t *address) {
 			continue;
 		if(owner && cache_mac_subnet[i] && cache_mac_subnet[i]->owner != owner)
 			continue;
+		if(vlan_id != cache_mac_vlan_id[i])
+			continue;
 		if(!memcmp(address, &cache_mac_address[i], sizeof *address))
 			return cache_mac_subnet[i];
 	}
@@ -425,7 +437,7 @@ subnet_t *lookup_subnet_mac(const node_t *owner, const mac_t *address) {
 		if(!p || p->type != SUBNET_MAC)
 			continue;
 
-		if(!memcmp(address, &p->net.mac.address, sizeof *address)) {
+		if(!memcmp(address, &p->net.mac.address, sizeof *address) && (vlan_id == p->net.mac.vlan)) {
 			r = p;
 			if(p->owner->status.reachable)
 				break;
@@ -437,6 +449,7 @@ subnet_t *lookup_subnet_mac(const node_t *owner, const mac_t *address) {
 	cache_mac_slot = !cache_mac_slot;
 	memcpy(&cache_mac_address[cache_mac_slot], address, sizeof *address);
 	cache_mac_subnet[cache_mac_slot] = r;
+	cache_mac_vlan_id[cache_mac_slot] = vlan_id;
 	cache_mac_valid[cache_mac_slot] = true;
 
 	return r;
diff --git a/src/subnet.h b/src/subnet.h
index e129a95..bed6919 100644
--- a/src/subnet.h
+++ b/src/subnet.h
@@ -32,6 +32,7 @@ typedef enum subnet_type_t {
 
 typedef struct subnet_mac_t {
 	mac_t address;
+	vlan_t vlan;
 } subnet_mac_t;
 
 typedef struct subnet_ipv4_t {
@@ -79,7 +80,7 @@ extern void subnet_update(struct node_t *, subnet_t *, bool);
 extern bool net2str(char *, int, const subnet_t *);
 extern bool str2net(subnet_t *, const char *);
 extern subnet_t *lookup_subnet(const struct node_t *, const subnet_t *);
-extern subnet_t *lookup_subnet_mac(const struct node_t *, const mac_t *);
+extern subnet_t *lookup_subnet_mac(const struct node_t *, const mac_t *, const vlan_t);
 extern subnet_t *lookup_subnet_ipv4(const ipv4_t *);
 extern subnet_t *lookup_subnet_ipv6(const ipv6_t *);
 extern void dump_subnets(void);
